// 2026-01-31 - Generated by MCP Forge v2.1.0
// Template: supabase v1.0.0
// Server: cc-data
// Project: ContextCommand

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { createClient, SupabaseClient } from "@supabase/supabase-js";

// ============= Forge Metadata =============
const __FORGE_META__ = {
  "generated_at": "2026-01-31T22:30:00.000Z",
  "template": "supabase",
  "template_version": "1.0.0",
  "forge_version": "2.1.0",
  "parent_server": null,
  "contextcommand_project": "ContextCommand",
  "modifications": []
};

// ============= Supabase Client =============
const supabaseUrl = process.env.SUPABASE_URL;
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY;
const supabaseServiceKey = process.env.SUPABASE_SERVICE_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  console.error("Missing required environment variables: SUPABASE_URL and SUPABASE_ANON_KEY");
  process.exit(1);
}

// Use service key if available for admin operations, otherwise anon key
const supabase: SupabaseClient = createClient(
  supabaseUrl,
  supabaseServiceKey || supabaseAnonKey
);

// ============= Server Setup =============
const server = new McpServer({
  name: "cc-data",
  version: "1.0.0"
});

// ============= Tool Implementations =============

// Tool: query
server.registerTool(
  "query",
  {
    title: "Query",
    description: `Execute a SELECT query on any table with optional filters`,
    inputSchema: z.object({
      table: z.string().describe("Table name"),
      select: z.string().describe("Columns to select").default("*").optional(),
      filter: z.record(z.unknown()).describe("Filter conditions").optional(),
      limit: z.number().describe("Max rows").default(100).optional(),
    }).strict(),
    annotations: {
      readOnlyHint: true,
      destructiveHint: false,
      idempotentHint: true,
      openWorldHint: true,
    }
  },
  async (params) => {
    try {
      let query = supabase
        .from(params.table)
        .select(params.select || "*")
        .limit(params.limit || 100);

      // Apply filters if provided
      if (params.filter) {
        for (const [key, value] of Object.entries(params.filter)) {
          query = query.eq(key, value);
        }
      }

      const { data, error } = await query;

      if (error) throw error;

      return {
        content: [{ type: "text", text: JSON.stringify(data, null, 2) }],
        structuredContent: { success: true, data, count: data?.length || 0 }
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return {
        isError: true,
        content: [{ type: "text", text: `Error in query: ${message}` }]
      };
    }
  }
);

// Tool: insert
server.registerTool(
  "insert",
  {
    title: "Insert",
    description: `Insert one or more rows into a table`,
    inputSchema: z.object({
      table: z.string().describe("Table name"),
      data: z.union([z.record(z.unknown()), z.array(z.record(z.unknown()))]).describe("Row data or array of rows"),
    }).strict(),
    annotations: {
      readOnlyHint: false,
      destructiveHint: true,
      idempotentHint: false,
      openWorldHint: true,
    }
  },
  async (params) => {
    try {
      const { data, error } = await supabase
        .from(params.table)
        .insert(params.data)
        .select();

      if (error) throw error;

      return {
        content: [{ type: "text", text: JSON.stringify(data, null, 2) }],
        structuredContent: { success: true, inserted: data }
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return {
        isError: true,
        content: [{ type: "text", text: `Error in insert: ${message}` }]
      };
    }
  }
);

// Tool: update
server.registerTool(
  "update",
  {
    title: "Update",
    description: `Update rows matching filter conditions`,
    inputSchema: z.object({
      table: z.string().describe("Table name"),
      data: z.record(z.unknown()).describe("Fields to update"),
      filter: z.record(z.unknown()).describe("Filter conditions"),
    }).strict(),
    annotations: {
      readOnlyHint: false,
      destructiveHint: true,
      idempotentHint: false,
      openWorldHint: true,
    }
  },
  async (params) => {
    try {
      let query = supabase
        .from(params.table)
        .update(params.data);

      // Apply filters
      for (const [key, value] of Object.entries(params.filter)) {
        query = query.eq(key, value);
      }

      const { data, error } = await query.select();

      if (error) throw error;

      return {
        content: [{ type: "text", text: JSON.stringify(data, null, 2) }],
        structuredContent: { success: true, updated: data }
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return {
        isError: true,
        content: [{ type: "text", text: `Error in update: ${message}` }]
      };
    }
  }
);

// Tool: delete
server.registerTool(
  "delete",
  {
    title: "Delete",
    description: `Delete rows matching filter conditions`,
    inputSchema: z.object({
      table: z.string().describe("Table name"),
      filter: z.record(z.unknown()).describe("Filter conditions"),
    }).strict(),
    annotations: {
      readOnlyHint: false,
      destructiveHint: true,
      idempotentHint: false,
      openWorldHint: true,
    }
  },
  async (params) => {
    try {
      let query = supabase
        .from(params.table)
        .delete();

      // Apply filters
      for (const [key, value] of Object.entries(params.filter)) {
        query = query.eq(key, value);
      }

      const { data, error } = await query.select();

      if (error) throw error;

      return {
        content: [{ type: "text", text: JSON.stringify({ deleted: data?.length || 0 }, null, 2) }],
        structuredContent: { success: true, deleted: data }
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return {
        isError: true,
        content: [{ type: "text", text: `Error in delete: ${message}` }]
      };
    }
  }
);

// Tool: rpc
server.registerTool(
  "rpc",
  {
    title: "Rpc",
    description: `Call a Postgres function`,
    inputSchema: z.object({
      function_name: z.string().describe("Function name"),
      params: z.record(z.unknown()).describe("Function parameters").optional(),
    }).strict(),
    annotations: {
      readOnlyHint: false,
      destructiveHint: false,
      idempotentHint: false,
      openWorldHint: true,
    }
  },
  async (params) => {
    try {
      const { data, error } = await supabase.rpc(
        params.function_name,
        params.params || {}
      );

      if (error) throw error;

      return {
        content: [{ type: "text", text: JSON.stringify(data, null, 2) }],
        structuredContent: { success: true, result: data }
      };
    } catch (error) {
      const message = error instanceof Error ? error.message : "Unknown error";
      return {
        isError: true,
        content: [{ type: "text", text: `Error in rpc: ${message}` }]
      };
    }
  }
);

// ============= Server Startup =============
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("cc-data MCP server running on stdio");
  console.error("Project: ContextCommand");
}

main().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});
